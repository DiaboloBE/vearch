// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: raftcmd.proto

#ifndef PROTOBUF_INCLUDED_raftcmd_2eproto
#define PROTOBUF_INCLUDED_raftcmd_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "errors.pb.h"
#include "data_model.pb.h"
#include "router_grpc.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_raftcmd_2eproto 

namespace protobuf_raftcmd_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_raftcmd_2eproto
class DocCmd;
class DocCmdDefaultTypeInternal;
extern DocCmdDefaultTypeInternal _DocCmd_default_instance_;
class PartitionData;
class PartitionDataDefaultTypeInternal;
extern PartitionDataDefaultTypeInternal _PartitionData_default_instance_;
class RaftCommand;
class RaftCommandDefaultTypeInternal;
extern RaftCommandDefaultTypeInternal _RaftCommand_default_instance_;
class SnapData;
class SnapDataDefaultTypeInternal;
extern SnapDataDefaultTypeInternal _SnapData_default_instance_;
class UpdateSpace;
class UpdateSpaceDefaultTypeInternal;
extern UpdateSpaceDefaultTypeInternal _UpdateSpace_default_instance_;
namespace google {
namespace protobuf {
template<> ::DocCmd* Arena::CreateMaybeMessage<::DocCmd>(Arena*);
template<> ::PartitionData* Arena::CreateMaybeMessage<::PartitionData>(Arena*);
template<> ::RaftCommand* Arena::CreateMaybeMessage<::RaftCommand>(Arena*);
template<> ::SnapData* Arena::CreateMaybeMessage<::SnapData>(Arena*);
template<> ::UpdateSpace* Arena::CreateMaybeMessage<::UpdateSpace>(Arena*);
}  // namespace protobuf
}  // namespace google

enum OpType {
  CREATE = 0,
  DELETE = 1,
  BULK = 2,
  GET = 3,
  SEARCH = 4,
  OpType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  OpType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool OpType_IsValid(int value);
const OpType OpType_MIN = CREATE;
const OpType OpType_MAX = SEARCH;
const int OpType_ARRAYSIZE = OpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OpType_descriptor();
inline const ::std::string& OpType_Name(OpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OpType_descriptor(), value);
}
inline bool OpType_Parse(
    const ::std::string& name, OpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OpType>(
    OpType_descriptor(), name, value);
}
enum CmdType {
  WRITE = 0,
  UPDATESPACE = 1,
  FLUSH = 2,
  SEARCHDEL = 3,
  CmdType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CmdType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CmdType_IsValid(int value);
const CmdType CmdType_MIN = WRITE;
const CmdType CmdType_MAX = SEARCHDEL;
const int CmdType_ARRAYSIZE = CmdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CmdType_descriptor();
inline const ::std::string& CmdType_Name(CmdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CmdType_descriptor(), value);
}
inline bool CmdType_Parse(
    const ::std::string& name, CmdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CmdType>(
    CmdType_descriptor(), name, value);
}
// ===================================================================

class PartitionData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PartitionData) */ {
 public:
  PartitionData();
  virtual ~PartitionData();

  PartitionData(const PartitionData& from);

  inline PartitionData& operator=(const PartitionData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartitionData(PartitionData&& from) noexcept
    : PartitionData() {
    *this = ::std::move(from);
  }

  inline PartitionData& operator=(PartitionData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PartitionData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionData* internal_default_instance() {
    return reinterpret_cast<const PartitionData*>(
               &_PartitionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PartitionData* other);
  friend void swap(PartitionData& a, PartitionData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartitionData* New() const final {
    return CreateMaybeMessage<PartitionData>(NULL);
  }

  PartitionData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PartitionData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PartitionData& from);
  void MergeFrom(const PartitionData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Item items = 4;
  int items_size() const;
  void clear_items();
  static const int kItemsFieldNumber = 4;
  ::Item* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::Item >*
      mutable_items();
  const ::Item& items(int index) const;
  ::Item* add_items();
  const ::google::protobuf::RepeatedPtrField< ::Item >&
      items() const;

  // repeated .SearchRequest search_requests = 9;
  int search_requests_size() const;
  void clear_search_requests();
  static const int kSearchRequestsFieldNumber = 9;
  ::SearchRequest* mutable_search_requests(int index);
  ::google::protobuf::RepeatedPtrField< ::SearchRequest >*
      mutable_search_requests();
  const ::SearchRequest& search_requests(int index) const;
  ::SearchRequest* add_search_requests();
  const ::google::protobuf::RepeatedPtrField< ::SearchRequest >&
      search_requests() const;

  // repeated .SearchResponse search_responses = 10;
  int search_responses_size() const;
  void clear_search_responses();
  static const int kSearchResponsesFieldNumber = 10;
  ::SearchResponse* mutable_search_responses(int index);
  ::google::protobuf::RepeatedPtrField< ::SearchResponse >*
      mutable_search_responses();
  const ::SearchResponse& search_responses(int index) const;
  ::SearchResponse* add_search_responses();
  const ::google::protobuf::RepeatedPtrField< ::SearchResponse >&
      search_responses() const;

  // string messageID = 3;
  void clear_messageid();
  static const int kMessageIDFieldNumber = 3;
  const ::std::string& messageid() const;
  void set_messageid(const ::std::string& value);
  #if LANG_CXX11
  void set_messageid(::std::string&& value);
  #endif
  void set_messageid(const char* value);
  void set_messageid(const char* value, size_t size);
  ::std::string* mutable_messageid();
  ::std::string* release_messageid();
  void set_allocated_messageid(::std::string* messageid);

  // bytes data = 7;
  void clear_data();
  static const int kDataFieldNumber = 7;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // .SearchRequest search_request = 5;
  bool has_search_request() const;
  void clear_search_request();
  static const int kSearchRequestFieldNumber = 5;
  private:
  const ::SearchRequest& _internal_search_request() const;
  public:
  const ::SearchRequest& search_request() const;
  ::SearchRequest* release_search_request();
  ::SearchRequest* mutable_search_request();
  void set_allocated_search_request(::SearchRequest* search_request);

  // .SearchResponse search_response = 6;
  bool has_search_response() const;
  void clear_search_response();
  static const int kSearchResponseFieldNumber = 6;
  private:
  const ::SearchResponse& _internal_search_response() const;
  public:
  const ::SearchResponse& search_response() const;
  ::SearchResponse* release_search_response();
  ::SearchResponse* mutable_search_response();
  void set_allocated_search_response(::SearchResponse* search_response);

  // .Error err = 8;
  bool has_err() const;
  void clear_err();
  static const int kErrFieldNumber = 8;
  private:
  const ::Error& _internal_err() const;
  public:
  const ::Error& err() const;
  ::Error* release_err();
  ::Error* mutable_err();
  void set_allocated_err(::Error* err);

  // .DelByQueryeResponse del_by_query_response = 12;
  bool has_del_by_query_response() const;
  void clear_del_by_query_response();
  static const int kDelByQueryResponseFieldNumber = 12;
  private:
  const ::DelByQueryeResponse& _internal_del_by_query_response() const;
  public:
  const ::DelByQueryeResponse& del_by_query_response() const;
  ::DelByQueryeResponse* release_del_by_query_response();
  ::DelByQueryeResponse* mutable_del_by_query_response();
  void set_allocated_del_by_query_response(::DelByQueryeResponse* del_by_query_response);

  // .IndexRequest index_request = 13;
  bool has_index_request() const;
  void clear_index_request();
  static const int kIndexRequestFieldNumber = 13;
  private:
  const ::IndexRequest& _internal_index_request() const;
  public:
  const ::IndexRequest& index_request() const;
  ::IndexRequest* release_index_request();
  ::IndexRequest* mutable_index_request();
  void set_allocated_index_request(::IndexRequest* index_request);

  // .IndexResponse index_response = 14;
  bool has_index_response() const;
  void clear_index_response();
  static const int kIndexResponseFieldNumber = 14;
  private:
  const ::IndexResponse& _internal_index_response() const;
  public:
  const ::IndexResponse& index_response() const;
  ::IndexResponse* release_index_response();
  ::IndexResponse* mutable_index_response();
  void set_allocated_index_response(::IndexResponse* index_response);

  // .QueryRequest query_request = 15;
  bool has_query_request() const;
  void clear_query_request();
  static const int kQueryRequestFieldNumber = 15;
  private:
  const ::QueryRequest& _internal_query_request() const;
  public:
  const ::QueryRequest& query_request() const;
  ::QueryRequest* release_query_request();
  ::QueryRequest* mutable_query_request();
  void set_allocated_query_request(::QueryRequest* query_request);

  // .OpType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::OpType type() const;
  void set_type(::OpType value);

  // uint32 partitionID = 2;
  void clear_partitionid();
  static const int kPartitionIDFieldNumber = 2;
  ::google::protobuf::uint32 partitionid() const;
  void set_partitionid(::google::protobuf::uint32 value);

  // int32 del_num = 11;
  void clear_del_num();
  static const int kDelNumFieldNumber = 11;
  ::google::protobuf::int32 del_num() const;
  void set_del_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:PartitionData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Item > items_;
  ::google::protobuf::RepeatedPtrField< ::SearchRequest > search_requests_;
  ::google::protobuf::RepeatedPtrField< ::SearchResponse > search_responses_;
  ::google::protobuf::internal::ArenaStringPtr messageid_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::SearchRequest* search_request_;
  ::SearchResponse* search_response_;
  ::Error* err_;
  ::DelByQueryeResponse* del_by_query_response_;
  ::IndexRequest* index_request_;
  ::IndexResponse* index_response_;
  ::QueryRequest* query_request_;
  int type_;
  ::google::protobuf::uint32 partitionid_;
  ::google::protobuf::int32 del_num_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_raftcmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateSpace : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UpdateSpace) */ {
 public:
  UpdateSpace();
  virtual ~UpdateSpace();

  UpdateSpace(const UpdateSpace& from);

  inline UpdateSpace& operator=(const UpdateSpace& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateSpace(UpdateSpace&& from) noexcept
    : UpdateSpace() {
    *this = ::std::move(from);
  }

  inline UpdateSpace& operator=(UpdateSpace&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateSpace& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateSpace* internal_default_instance() {
    return reinterpret_cast<const UpdateSpace*>(
               &_UpdateSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(UpdateSpace* other);
  friend void swap(UpdateSpace& a, UpdateSpace& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateSpace* New() const final {
    return CreateMaybeMessage<UpdateSpace>(NULL);
  }

  UpdateSpace* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateSpace>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateSpace& from);
  void MergeFrom(const UpdateSpace& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateSpace* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes Space = 1;
  void clear_space();
  static const int kSpaceFieldNumber = 1;
  const ::std::string& space() const;
  void set_space(const ::std::string& value);
  #if LANG_CXX11
  void set_space(::std::string&& value);
  #endif
  void set_space(const char* value);
  void set_space(const void* value, size_t size);
  ::std::string* mutable_space();
  ::std::string* release_space();
  void set_allocated_space(::std::string* space);

  // uint64 version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  ::google::protobuf::uint64 version() const;
  void set_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:UpdateSpace)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr space_;
  ::google::protobuf::uint64 version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_raftcmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DocCmd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DocCmd) */ {
 public:
  DocCmd();
  virtual ~DocCmd();

  DocCmd(const DocCmd& from);

  inline DocCmd& operator=(const DocCmd& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DocCmd(DocCmd&& from) noexcept
    : DocCmd() {
    *this = ::std::move(from);
  }

  inline DocCmd& operator=(DocCmd&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DocCmd& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DocCmd* internal_default_instance() {
    return reinterpret_cast<const DocCmd*>(
               &_DocCmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DocCmd* other);
  friend void swap(DocCmd& a, DocCmd& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DocCmd* New() const final {
    return CreateMaybeMessage<DocCmd>(NULL);
  }

  DocCmd* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DocCmd>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DocCmd& from);
  void MergeFrom(const DocCmd& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocCmd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes docs = 8;
  int docs_size() const;
  void clear_docs();
  static const int kDocsFieldNumber = 8;
  const ::std::string& docs(int index) const;
  ::std::string* mutable_docs(int index);
  void set_docs(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_docs(int index, ::std::string&& value);
  #endif
  void set_docs(int index, const char* value);
  void set_docs(int index, const void* value, size_t size);
  ::std::string* add_docs();
  void add_docs(const ::std::string& value);
  #if LANG_CXX11
  void add_docs(::std::string&& value);
  #endif
  void add_docs(const char* value);
  void add_docs(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& docs() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_docs();

  // bytes doc = 7;
  void clear_doc();
  static const int kDocFieldNumber = 7;
  const ::std::string& doc() const;
  void set_doc(const ::std::string& value);
  #if LANG_CXX11
  void set_doc(::std::string&& value);
  #endif
  void set_doc(const char* value);
  void set_doc(const void* value, size_t size);
  ::std::string* mutable_doc();
  ::std::string* release_doc();
  void set_allocated_doc(::std::string* doc);

  // int64 version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  ::google::protobuf::int64 version() const;
  void set_version(::google::protobuf::int64 value);

  // .OpType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::OpType type() const;
  void set_type(::OpType value);

  // uint32 slot = 5;
  void clear_slot();
  static const int kSlotFieldNumber = 5;
  ::google::protobuf::uint32 slot() const;
  void set_slot(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:DocCmd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> docs_;
  ::google::protobuf::internal::ArenaStringPtr doc_;
  ::google::protobuf::int64 version_;
  int type_;
  ::google::protobuf::uint32 slot_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_raftcmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RaftCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RaftCommand) */ {
 public:
  RaftCommand();
  virtual ~RaftCommand();

  RaftCommand(const RaftCommand& from);

  inline RaftCommand& operator=(const RaftCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RaftCommand(RaftCommand&& from) noexcept
    : RaftCommand() {
    *this = ::std::move(from);
  }

  inline RaftCommand& operator=(RaftCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RaftCommand* internal_default_instance() {
    return reinterpret_cast<const RaftCommand*>(
               &_RaftCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RaftCommand* other);
  friend void swap(RaftCommand& a, RaftCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RaftCommand* New() const final {
    return CreateMaybeMessage<RaftCommand>(NULL);
  }

  RaftCommand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RaftCommand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RaftCommand& from);
  void MergeFrom(const RaftCommand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RaftCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .DocCmd write_command = 2;
  bool has_write_command() const;
  void clear_write_command();
  static const int kWriteCommandFieldNumber = 2;
  private:
  const ::DocCmd& _internal_write_command() const;
  public:
  const ::DocCmd& write_command() const;
  ::DocCmd* release_write_command();
  ::DocCmd* mutable_write_command();
  void set_allocated_write_command(::DocCmd* write_command);

  // .UpdateSpace update_space = 3;
  bool has_update_space() const;
  void clear_update_space();
  static const int kUpdateSpaceFieldNumber = 3;
  private:
  const ::UpdateSpace& _internal_update_space() const;
  public:
  const ::UpdateSpace& update_space() const;
  ::UpdateSpace* release_update_space();
  ::UpdateSpace* mutable_update_space();
  void set_allocated_update_space(::UpdateSpace* update_space);

  // .CmdType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::CmdType type() const;
  void set_type(::CmdType value);

  // @@protoc_insertion_point(class_scope:RaftCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::DocCmd* write_command_;
  ::UpdateSpace* update_space_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_raftcmd_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SnapData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SnapData) */ {
 public:
  SnapData();
  virtual ~SnapData();

  SnapData(const SnapData& from);

  inline SnapData& operator=(const SnapData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SnapData(SnapData&& from) noexcept
    : SnapData() {
    *this = ::std::move(from);
  }

  inline SnapData& operator=(SnapData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SnapData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnapData* internal_default_instance() {
    return reinterpret_cast<const SnapData*>(
               &_SnapData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SnapData* other);
  friend void swap(SnapData& a, SnapData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SnapData* New() const final {
    return CreateMaybeMessage<SnapData>(NULL);
  }

  SnapData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SnapData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SnapData& from);
  void MergeFrom(const SnapData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:SnapData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_raftcmd_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PartitionData

// .OpType type = 1;
inline void PartitionData::clear_type() {
  type_ = 0;
}
inline ::OpType PartitionData::type() const {
  // @@protoc_insertion_point(field_get:PartitionData.type)
  return static_cast< ::OpType >(type_);
}
inline void PartitionData::set_type(::OpType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:PartitionData.type)
}

// uint32 partitionID = 2;
inline void PartitionData::clear_partitionid() {
  partitionid_ = 0u;
}
inline ::google::protobuf::uint32 PartitionData::partitionid() const {
  // @@protoc_insertion_point(field_get:PartitionData.partitionID)
  return partitionid_;
}
inline void PartitionData::set_partitionid(::google::protobuf::uint32 value) {
  
  partitionid_ = value;
  // @@protoc_insertion_point(field_set:PartitionData.partitionID)
}

// string messageID = 3;
inline void PartitionData::clear_messageid() {
  messageid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartitionData::messageid() const {
  // @@protoc_insertion_point(field_get:PartitionData.messageID)
  return messageid_.GetNoArena();
}
inline void PartitionData::set_messageid(const ::std::string& value) {
  
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PartitionData.messageID)
}
#if LANG_CXX11
inline void PartitionData::set_messageid(::std::string&& value) {
  
  messageid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PartitionData.messageID)
}
#endif
inline void PartitionData::set_messageid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PartitionData.messageID)
}
inline void PartitionData::set_messageid(const char* value, size_t size) {
  
  messageid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PartitionData.messageID)
}
inline ::std::string* PartitionData::mutable_messageid() {
  
  // @@protoc_insertion_point(field_mutable:PartitionData.messageID)
  return messageid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionData::release_messageid() {
  // @@protoc_insertion_point(field_release:PartitionData.messageID)
  
  return messageid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionData::set_allocated_messageid(::std::string* messageid) {
  if (messageid != NULL) {
    
  } else {
    
  }
  messageid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messageid);
  // @@protoc_insertion_point(field_set_allocated:PartitionData.messageID)
}

// repeated .Item items = 4;
inline int PartitionData::items_size() const {
  return items_.size();
}
inline ::Item* PartitionData::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:PartitionData.items)
  return items_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Item >*
PartitionData::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:PartitionData.items)
  return &items_;
}
inline const ::Item& PartitionData::items(int index) const {
  // @@protoc_insertion_point(field_get:PartitionData.items)
  return items_.Get(index);
}
inline ::Item* PartitionData::add_items() {
  // @@protoc_insertion_point(field_add:PartitionData.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Item >&
PartitionData::items() const {
  // @@protoc_insertion_point(field_list:PartitionData.items)
  return items_;
}

// .SearchRequest search_request = 5;
inline bool PartitionData::has_search_request() const {
  return this != internal_default_instance() && search_request_ != NULL;
}
inline const ::SearchRequest& PartitionData::_internal_search_request() const {
  return *search_request_;
}
inline const ::SearchRequest& PartitionData::search_request() const {
  const ::SearchRequest* p = search_request_;
  // @@protoc_insertion_point(field_get:PartitionData.search_request)
  return p != NULL ? *p : *reinterpret_cast<const ::SearchRequest*>(
      &::_SearchRequest_default_instance_);
}
inline ::SearchRequest* PartitionData::release_search_request() {
  // @@protoc_insertion_point(field_release:PartitionData.search_request)
  
  ::SearchRequest* temp = search_request_;
  search_request_ = NULL;
  return temp;
}
inline ::SearchRequest* PartitionData::mutable_search_request() {
  
  if (search_request_ == NULL) {
    auto* p = CreateMaybeMessage<::SearchRequest>(GetArenaNoVirtual());
    search_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PartitionData.search_request)
  return search_request_;
}
inline void PartitionData::set_allocated_search_request(::SearchRequest* search_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(search_request_);
  }
  if (search_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      search_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, search_request, submessage_arena);
    }
    
  } else {
    
  }
  search_request_ = search_request;
  // @@protoc_insertion_point(field_set_allocated:PartitionData.search_request)
}

// .SearchResponse search_response = 6;
inline bool PartitionData::has_search_response() const {
  return this != internal_default_instance() && search_response_ != NULL;
}
inline const ::SearchResponse& PartitionData::_internal_search_response() const {
  return *search_response_;
}
inline const ::SearchResponse& PartitionData::search_response() const {
  const ::SearchResponse* p = search_response_;
  // @@protoc_insertion_point(field_get:PartitionData.search_response)
  return p != NULL ? *p : *reinterpret_cast<const ::SearchResponse*>(
      &::_SearchResponse_default_instance_);
}
inline ::SearchResponse* PartitionData::release_search_response() {
  // @@protoc_insertion_point(field_release:PartitionData.search_response)
  
  ::SearchResponse* temp = search_response_;
  search_response_ = NULL;
  return temp;
}
inline ::SearchResponse* PartitionData::mutable_search_response() {
  
  if (search_response_ == NULL) {
    auto* p = CreateMaybeMessage<::SearchResponse>(GetArenaNoVirtual());
    search_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PartitionData.search_response)
  return search_response_;
}
inline void PartitionData::set_allocated_search_response(::SearchResponse* search_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(search_response_);
  }
  if (search_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      search_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, search_response, submessage_arena);
    }
    
  } else {
    
  }
  search_response_ = search_response;
  // @@protoc_insertion_point(field_set_allocated:PartitionData.search_response)
}

// bytes data = 7;
inline void PartitionData::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartitionData::data() const {
  // @@protoc_insertion_point(field_get:PartitionData.data)
  return data_.GetNoArena();
}
inline void PartitionData::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PartitionData.data)
}
#if LANG_CXX11
inline void PartitionData::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PartitionData.data)
}
#endif
inline void PartitionData::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PartitionData.data)
}
inline void PartitionData::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PartitionData.data)
}
inline ::std::string* PartitionData::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:PartitionData.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionData::release_data() {
  // @@protoc_insertion_point(field_release:PartitionData.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionData::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:PartitionData.data)
}

// .Error err = 8;
inline bool PartitionData::has_err() const {
  return this != internal_default_instance() && err_ != NULL;
}
inline const ::Error& PartitionData::_internal_err() const {
  return *err_;
}
inline const ::Error& PartitionData::err() const {
  const ::Error* p = err_;
  // @@protoc_insertion_point(field_get:PartitionData.err)
  return p != NULL ? *p : *reinterpret_cast<const ::Error*>(
      &::_Error_default_instance_);
}
inline ::Error* PartitionData::release_err() {
  // @@protoc_insertion_point(field_release:PartitionData.err)
  
  ::Error* temp = err_;
  err_ = NULL;
  return temp;
}
inline ::Error* PartitionData::mutable_err() {
  
  if (err_ == NULL) {
    auto* p = CreateMaybeMessage<::Error>(GetArenaNoVirtual());
    err_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PartitionData.err)
  return err_;
}
inline void PartitionData::set_allocated_err(::Error* err) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(err_);
  }
  if (err) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      err = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, err, submessage_arena);
    }
    
  } else {
    
  }
  err_ = err;
  // @@protoc_insertion_point(field_set_allocated:PartitionData.err)
}

// repeated .SearchRequest search_requests = 9;
inline int PartitionData::search_requests_size() const {
  return search_requests_.size();
}
inline ::SearchRequest* PartitionData::mutable_search_requests(int index) {
  // @@protoc_insertion_point(field_mutable:PartitionData.search_requests)
  return search_requests_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SearchRequest >*
PartitionData::mutable_search_requests() {
  // @@protoc_insertion_point(field_mutable_list:PartitionData.search_requests)
  return &search_requests_;
}
inline const ::SearchRequest& PartitionData::search_requests(int index) const {
  // @@protoc_insertion_point(field_get:PartitionData.search_requests)
  return search_requests_.Get(index);
}
inline ::SearchRequest* PartitionData::add_search_requests() {
  // @@protoc_insertion_point(field_add:PartitionData.search_requests)
  return search_requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SearchRequest >&
PartitionData::search_requests() const {
  // @@protoc_insertion_point(field_list:PartitionData.search_requests)
  return search_requests_;
}

// repeated .SearchResponse search_responses = 10;
inline int PartitionData::search_responses_size() const {
  return search_responses_.size();
}
inline ::SearchResponse* PartitionData::mutable_search_responses(int index) {
  // @@protoc_insertion_point(field_mutable:PartitionData.search_responses)
  return search_responses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::SearchResponse >*
PartitionData::mutable_search_responses() {
  // @@protoc_insertion_point(field_mutable_list:PartitionData.search_responses)
  return &search_responses_;
}
inline const ::SearchResponse& PartitionData::search_responses(int index) const {
  // @@protoc_insertion_point(field_get:PartitionData.search_responses)
  return search_responses_.Get(index);
}
inline ::SearchResponse* PartitionData::add_search_responses() {
  // @@protoc_insertion_point(field_add:PartitionData.search_responses)
  return search_responses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SearchResponse >&
PartitionData::search_responses() const {
  // @@protoc_insertion_point(field_list:PartitionData.search_responses)
  return search_responses_;
}

// int32 del_num = 11;
inline void PartitionData::clear_del_num() {
  del_num_ = 0;
}
inline ::google::protobuf::int32 PartitionData::del_num() const {
  // @@protoc_insertion_point(field_get:PartitionData.del_num)
  return del_num_;
}
inline void PartitionData::set_del_num(::google::protobuf::int32 value) {
  
  del_num_ = value;
  // @@protoc_insertion_point(field_set:PartitionData.del_num)
}

// .DelByQueryeResponse del_by_query_response = 12;
inline bool PartitionData::has_del_by_query_response() const {
  return this != internal_default_instance() && del_by_query_response_ != NULL;
}
inline const ::DelByQueryeResponse& PartitionData::_internal_del_by_query_response() const {
  return *del_by_query_response_;
}
inline const ::DelByQueryeResponse& PartitionData::del_by_query_response() const {
  const ::DelByQueryeResponse* p = del_by_query_response_;
  // @@protoc_insertion_point(field_get:PartitionData.del_by_query_response)
  return p != NULL ? *p : *reinterpret_cast<const ::DelByQueryeResponse*>(
      &::_DelByQueryeResponse_default_instance_);
}
inline ::DelByQueryeResponse* PartitionData::release_del_by_query_response() {
  // @@protoc_insertion_point(field_release:PartitionData.del_by_query_response)
  
  ::DelByQueryeResponse* temp = del_by_query_response_;
  del_by_query_response_ = NULL;
  return temp;
}
inline ::DelByQueryeResponse* PartitionData::mutable_del_by_query_response() {
  
  if (del_by_query_response_ == NULL) {
    auto* p = CreateMaybeMessage<::DelByQueryeResponse>(GetArenaNoVirtual());
    del_by_query_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PartitionData.del_by_query_response)
  return del_by_query_response_;
}
inline void PartitionData::set_allocated_del_by_query_response(::DelByQueryeResponse* del_by_query_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(del_by_query_response_);
  }
  if (del_by_query_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      del_by_query_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, del_by_query_response, submessage_arena);
    }
    
  } else {
    
  }
  del_by_query_response_ = del_by_query_response;
  // @@protoc_insertion_point(field_set_allocated:PartitionData.del_by_query_response)
}

// .IndexRequest index_request = 13;
inline bool PartitionData::has_index_request() const {
  return this != internal_default_instance() && index_request_ != NULL;
}
inline const ::IndexRequest& PartitionData::_internal_index_request() const {
  return *index_request_;
}
inline const ::IndexRequest& PartitionData::index_request() const {
  const ::IndexRequest* p = index_request_;
  // @@protoc_insertion_point(field_get:PartitionData.index_request)
  return p != NULL ? *p : *reinterpret_cast<const ::IndexRequest*>(
      &::_IndexRequest_default_instance_);
}
inline ::IndexRequest* PartitionData::release_index_request() {
  // @@protoc_insertion_point(field_release:PartitionData.index_request)
  
  ::IndexRequest* temp = index_request_;
  index_request_ = NULL;
  return temp;
}
inline ::IndexRequest* PartitionData::mutable_index_request() {
  
  if (index_request_ == NULL) {
    auto* p = CreateMaybeMessage<::IndexRequest>(GetArenaNoVirtual());
    index_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PartitionData.index_request)
  return index_request_;
}
inline void PartitionData::set_allocated_index_request(::IndexRequest* index_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(index_request_);
  }
  if (index_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      index_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, index_request, submessage_arena);
    }
    
  } else {
    
  }
  index_request_ = index_request;
  // @@protoc_insertion_point(field_set_allocated:PartitionData.index_request)
}

// .IndexResponse index_response = 14;
inline bool PartitionData::has_index_response() const {
  return this != internal_default_instance() && index_response_ != NULL;
}
inline const ::IndexResponse& PartitionData::_internal_index_response() const {
  return *index_response_;
}
inline const ::IndexResponse& PartitionData::index_response() const {
  const ::IndexResponse* p = index_response_;
  // @@protoc_insertion_point(field_get:PartitionData.index_response)
  return p != NULL ? *p : *reinterpret_cast<const ::IndexResponse*>(
      &::_IndexResponse_default_instance_);
}
inline ::IndexResponse* PartitionData::release_index_response() {
  // @@protoc_insertion_point(field_release:PartitionData.index_response)
  
  ::IndexResponse* temp = index_response_;
  index_response_ = NULL;
  return temp;
}
inline ::IndexResponse* PartitionData::mutable_index_response() {
  
  if (index_response_ == NULL) {
    auto* p = CreateMaybeMessage<::IndexResponse>(GetArenaNoVirtual());
    index_response_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PartitionData.index_response)
  return index_response_;
}
inline void PartitionData::set_allocated_index_response(::IndexResponse* index_response) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(index_response_);
  }
  if (index_response) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      index_response = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, index_response, submessage_arena);
    }
    
  } else {
    
  }
  index_response_ = index_response;
  // @@protoc_insertion_point(field_set_allocated:PartitionData.index_response)
}

// .QueryRequest query_request = 15;
inline bool PartitionData::has_query_request() const {
  return this != internal_default_instance() && query_request_ != NULL;
}
inline const ::QueryRequest& PartitionData::_internal_query_request() const {
  return *query_request_;
}
inline const ::QueryRequest& PartitionData::query_request() const {
  const ::QueryRequest* p = query_request_;
  // @@protoc_insertion_point(field_get:PartitionData.query_request)
  return p != NULL ? *p : *reinterpret_cast<const ::QueryRequest*>(
      &::_QueryRequest_default_instance_);
}
inline ::QueryRequest* PartitionData::release_query_request() {
  // @@protoc_insertion_point(field_release:PartitionData.query_request)
  
  ::QueryRequest* temp = query_request_;
  query_request_ = NULL;
  return temp;
}
inline ::QueryRequest* PartitionData::mutable_query_request() {
  
  if (query_request_ == NULL) {
    auto* p = CreateMaybeMessage<::QueryRequest>(GetArenaNoVirtual());
    query_request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:PartitionData.query_request)
  return query_request_;
}
inline void PartitionData::set_allocated_query_request(::QueryRequest* query_request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(query_request_);
  }
  if (query_request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      query_request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, query_request, submessage_arena);
    }
    
  } else {
    
  }
  query_request_ = query_request;
  // @@protoc_insertion_point(field_set_allocated:PartitionData.query_request)
}

// -------------------------------------------------------------------

// UpdateSpace

// bytes Space = 1;
inline void UpdateSpace::clear_space() {
  space_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UpdateSpace::space() const {
  // @@protoc_insertion_point(field_get:UpdateSpace.Space)
  return space_.GetNoArena();
}
inline void UpdateSpace::set_space(const ::std::string& value) {
  
  space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:UpdateSpace.Space)
}
#if LANG_CXX11
inline void UpdateSpace::set_space(::std::string&& value) {
  
  space_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:UpdateSpace.Space)
}
#endif
inline void UpdateSpace::set_space(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:UpdateSpace.Space)
}
inline void UpdateSpace::set_space(const void* value, size_t size) {
  
  space_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:UpdateSpace.Space)
}
inline ::std::string* UpdateSpace::mutable_space() {
  
  // @@protoc_insertion_point(field_mutable:UpdateSpace.Space)
  return space_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateSpace::release_space() {
  // @@protoc_insertion_point(field_release:UpdateSpace.Space)
  
  return space_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateSpace::set_allocated_space(::std::string* space) {
  if (space != NULL) {
    
  } else {
    
  }
  space_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), space);
  // @@protoc_insertion_point(field_set_allocated:UpdateSpace.Space)
}

// uint64 version = 2;
inline void UpdateSpace::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 UpdateSpace::version() const {
  // @@protoc_insertion_point(field_get:UpdateSpace.version)
  return version_;
}
inline void UpdateSpace::set_version(::google::protobuf::uint64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:UpdateSpace.version)
}

// -------------------------------------------------------------------

// DocCmd

// .OpType type = 1;
inline void DocCmd::clear_type() {
  type_ = 0;
}
inline ::OpType DocCmd::type() const {
  // @@protoc_insertion_point(field_get:DocCmd.type)
  return static_cast< ::OpType >(type_);
}
inline void DocCmd::set_type(::OpType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:DocCmd.type)
}

// int64 version = 3;
inline void DocCmd::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 DocCmd::version() const {
  // @@protoc_insertion_point(field_get:DocCmd.version)
  return version_;
}
inline void DocCmd::set_version(::google::protobuf::int64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:DocCmd.version)
}

// uint32 slot = 5;
inline void DocCmd::clear_slot() {
  slot_ = 0u;
}
inline ::google::protobuf::uint32 DocCmd::slot() const {
  // @@protoc_insertion_point(field_get:DocCmd.slot)
  return slot_;
}
inline void DocCmd::set_slot(::google::protobuf::uint32 value) {
  
  slot_ = value;
  // @@protoc_insertion_point(field_set:DocCmd.slot)
}

// bytes doc = 7;
inline void DocCmd::clear_doc() {
  doc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DocCmd::doc() const {
  // @@protoc_insertion_point(field_get:DocCmd.doc)
  return doc_.GetNoArena();
}
inline void DocCmd::set_doc(const ::std::string& value) {
  
  doc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:DocCmd.doc)
}
#if LANG_CXX11
inline void DocCmd::set_doc(::std::string&& value) {
  
  doc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:DocCmd.doc)
}
#endif
inline void DocCmd::set_doc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  doc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:DocCmd.doc)
}
inline void DocCmd::set_doc(const void* value, size_t size) {
  
  doc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:DocCmd.doc)
}
inline ::std::string* DocCmd::mutable_doc() {
  
  // @@protoc_insertion_point(field_mutable:DocCmd.doc)
  return doc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DocCmd::release_doc() {
  // @@protoc_insertion_point(field_release:DocCmd.doc)
  
  return doc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DocCmd::set_allocated_doc(::std::string* doc) {
  if (doc != NULL) {
    
  } else {
    
  }
  doc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), doc);
  // @@protoc_insertion_point(field_set_allocated:DocCmd.doc)
}

// repeated bytes docs = 8;
inline int DocCmd::docs_size() const {
  return docs_.size();
}
inline void DocCmd::clear_docs() {
  docs_.Clear();
}
inline const ::std::string& DocCmd::docs(int index) const {
  // @@protoc_insertion_point(field_get:DocCmd.docs)
  return docs_.Get(index);
}
inline ::std::string* DocCmd::mutable_docs(int index) {
  // @@protoc_insertion_point(field_mutable:DocCmd.docs)
  return docs_.Mutable(index);
}
inline void DocCmd::set_docs(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:DocCmd.docs)
  docs_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void DocCmd::set_docs(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:DocCmd.docs)
  docs_.Mutable(index)->assign(std::move(value));
}
#endif
inline void DocCmd::set_docs(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  docs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:DocCmd.docs)
}
inline void DocCmd::set_docs(int index, const void* value, size_t size) {
  docs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DocCmd.docs)
}
inline ::std::string* DocCmd::add_docs() {
  // @@protoc_insertion_point(field_add_mutable:DocCmd.docs)
  return docs_.Add();
}
inline void DocCmd::add_docs(const ::std::string& value) {
  docs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:DocCmd.docs)
}
#if LANG_CXX11
inline void DocCmd::add_docs(::std::string&& value) {
  docs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:DocCmd.docs)
}
#endif
inline void DocCmd::add_docs(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  docs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:DocCmd.docs)
}
inline void DocCmd::add_docs(const void* value, size_t size) {
  docs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:DocCmd.docs)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DocCmd::docs() const {
  // @@protoc_insertion_point(field_list:DocCmd.docs)
  return docs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DocCmd::mutable_docs() {
  // @@protoc_insertion_point(field_mutable_list:DocCmd.docs)
  return &docs_;
}

// -------------------------------------------------------------------

// RaftCommand

// .CmdType type = 1;
inline void RaftCommand::clear_type() {
  type_ = 0;
}
inline ::CmdType RaftCommand::type() const {
  // @@protoc_insertion_point(field_get:RaftCommand.type)
  return static_cast< ::CmdType >(type_);
}
inline void RaftCommand::set_type(::CmdType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:RaftCommand.type)
}

// .DocCmd write_command = 2;
inline bool RaftCommand::has_write_command() const {
  return this != internal_default_instance() && write_command_ != NULL;
}
inline void RaftCommand::clear_write_command() {
  if (GetArenaNoVirtual() == NULL && write_command_ != NULL) {
    delete write_command_;
  }
  write_command_ = NULL;
}
inline const ::DocCmd& RaftCommand::_internal_write_command() const {
  return *write_command_;
}
inline const ::DocCmd& RaftCommand::write_command() const {
  const ::DocCmd* p = write_command_;
  // @@protoc_insertion_point(field_get:RaftCommand.write_command)
  return p != NULL ? *p : *reinterpret_cast<const ::DocCmd*>(
      &::_DocCmd_default_instance_);
}
inline ::DocCmd* RaftCommand::release_write_command() {
  // @@protoc_insertion_point(field_release:RaftCommand.write_command)
  
  ::DocCmd* temp = write_command_;
  write_command_ = NULL;
  return temp;
}
inline ::DocCmd* RaftCommand::mutable_write_command() {
  
  if (write_command_ == NULL) {
    auto* p = CreateMaybeMessage<::DocCmd>(GetArenaNoVirtual());
    write_command_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RaftCommand.write_command)
  return write_command_;
}
inline void RaftCommand::set_allocated_write_command(::DocCmd* write_command) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete write_command_;
  }
  if (write_command) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      write_command = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, write_command, submessage_arena);
    }
    
  } else {
    
  }
  write_command_ = write_command;
  // @@protoc_insertion_point(field_set_allocated:RaftCommand.write_command)
}

// .UpdateSpace update_space = 3;
inline bool RaftCommand::has_update_space() const {
  return this != internal_default_instance() && update_space_ != NULL;
}
inline void RaftCommand::clear_update_space() {
  if (GetArenaNoVirtual() == NULL && update_space_ != NULL) {
    delete update_space_;
  }
  update_space_ = NULL;
}
inline const ::UpdateSpace& RaftCommand::_internal_update_space() const {
  return *update_space_;
}
inline const ::UpdateSpace& RaftCommand::update_space() const {
  const ::UpdateSpace* p = update_space_;
  // @@protoc_insertion_point(field_get:RaftCommand.update_space)
  return p != NULL ? *p : *reinterpret_cast<const ::UpdateSpace*>(
      &::_UpdateSpace_default_instance_);
}
inline ::UpdateSpace* RaftCommand::release_update_space() {
  // @@protoc_insertion_point(field_release:RaftCommand.update_space)
  
  ::UpdateSpace* temp = update_space_;
  update_space_ = NULL;
  return temp;
}
inline ::UpdateSpace* RaftCommand::mutable_update_space() {
  
  if (update_space_ == NULL) {
    auto* p = CreateMaybeMessage<::UpdateSpace>(GetArenaNoVirtual());
    update_space_ = p;
  }
  // @@protoc_insertion_point(field_mutable:RaftCommand.update_space)
  return update_space_;
}
inline void RaftCommand::set_allocated_update_space(::UpdateSpace* update_space) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete update_space_;
  }
  if (update_space) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      update_space = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, update_space, submessage_arena);
    }
    
  } else {
    
  }
  update_space_ = update_space;
  // @@protoc_insertion_point(field_set_allocated:RaftCommand.update_space)
}

// -------------------------------------------------------------------

// SnapData

// bytes key = 1;
inline void SnapData::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SnapData::key() const {
  // @@protoc_insertion_point(field_get:SnapData.key)
  return key_.GetNoArena();
}
inline void SnapData::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SnapData.key)
}
#if LANG_CXX11
inline void SnapData::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SnapData.key)
}
#endif
inline void SnapData::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SnapData.key)
}
inline void SnapData::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SnapData.key)
}
inline ::std::string* SnapData::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:SnapData.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SnapData::release_key() {
  // @@protoc_insertion_point(field_release:SnapData.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SnapData::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:SnapData.key)
}

// bytes value = 2;
inline void SnapData::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SnapData::value() const {
  // @@protoc_insertion_point(field_get:SnapData.value)
  return value_.GetNoArena();
}
inline void SnapData::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SnapData.value)
}
#if LANG_CXX11
inline void SnapData::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SnapData.value)
}
#endif
inline void SnapData::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SnapData.value)
}
inline void SnapData::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SnapData.value)
}
inline ::std::string* SnapData::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:SnapData.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SnapData::release_value() {
  // @@protoc_insertion_point(field_release:SnapData.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SnapData::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:SnapData.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::OpType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpType>() {
  return ::OpType_descriptor();
}
template <> struct is_proto_enum< ::CmdType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CmdType>() {
  return ::CmdType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_raftcmd_2eproto
